<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>自适应拼图游戏 · 组优先</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            overscroll-behavior: none;
            user-select: none;
            -webkit-user-select: none;
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
        }

        .page-section {
            transition: opacity 0.1s ease, transform 0.1s ease;
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            display: flex;
            flex-direction: column;
            background-color: #f1f5f9;
            overflow-y: auto;
        }

        .hidden-page {
            opacity: 0;
            pointer-events: none;
            z-index: -1;
            transform: scale(0.98);
            position: absolute;
        }

        .active-page {
            opacity: 1;
            pointer-events: auto;
            z-index: 10;
            transform: scale(1);
        }

        #gameBoard {
            position: relative;
            width: 100%;
            max-width: 500px;
            margin: 0 auto;
            background-color: white;
            padding: 1px;
            border-radius: 4px;
            touch-action: none;
            box-sizing: border-box;
            transition: height 0.3s ease;
        }

        .tile {
            position: absolute;
            transition: transform 0.1s cubic-bezier(0.2, 0.8, 0.2, 1);
            background-repeat: no-repeat;
            z-index: 10;
            box-sizing: border-box;
        }

        .tile.is-dragging {
            z-index: 50;
            transition: none;
            transform: scale(1.02);
            opacity: 0.95;
            filter: brightness(1.1);
        }

        .ghost-tile {
            position: absolute;
            background-color: rgba(99, 102, 241, 0.2);
            border: 2px dashed #6366f1;
            z-index: 5;
            pointer-events: none;
        }

        @keyframes pop {
            0% { transform: scale(0.8); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }
        .celebrate-modal {
            animation: pop 0.1s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
    </style>
</head>
<body class="h-screen w-screen overflow-hidden text-slate-800">

    <!-- 设置页 -->
    <div id="homePage" class="page-section active-page items-center justify-center p-6">
        <div class="w-full max-w-md bg-white rounded-2xl shadow-xl p-8 my-auto">
            <h1 class="text-2xl font-black text-center mb-1">STRICT PUZZLE</h1>
            <p class="text-center text-slate-400 text-xs mb-8">自适应长宽比 · 智能组移动</p>

            <div class="mb-6">
                <label class="text-xs font-bold text-slate-400 uppercase tracking-wider mb-2 block">Grid Size</label>
                <div class="grid grid-cols-3 gap-3">
                    <button onclick="selectMode(3)" class="mode-btn ring-2 ring-indigo-500 bg-indigo-50 text-indigo-700 py-3 rounded-lg text-sm font-bold" data-size="3">3 x 3</button>
                    <button onclick="selectMode(4)" class="mode-btn border border-slate-200 text-slate-600 hover:bg-slate-50 py-3 rounded-lg text-sm font-medium" data-size="4">4 x 4</button>
                    <button onclick="selectMode(5)" class="mode-btn border border-slate-200 text-slate-600 hover:bg-slate-50 py-3 rounded-lg text-sm font-medium" data-size="5">5 x 5</button>
                </div>
            </div>

            <div class="mb-8">
                <label class="text-xs font-bold text-slate-400 uppercase tracking-wider mb-2 block">Image</label>
                <label class="relative block w-full aspect-video rounded-lg overflow-hidden cursor-pointer group bg-slate-100 border-2 border-dashed border-slate-300 flex items-center justify-center">
                    <img id="previewThumb" class="w-full h-full object-cover" src="https://images.unsplash.com/photo-1579546929518-9e396f3cc809?ixlib=rb-4.0.3&auto=format&fit=crop&w=1000&q=80" />
                    <div class="absolute inset-0 bg-black/40 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity">
                        <span class="text-white text-xs font-bold">更换图片</span>
                    </div>
                    <input id="imageInput" type="file" class="hidden" accept="image/*" />
                </label>
                <p id="imgRatioInfo" class="text-center text-[10px] text-slate-400 mt-2 h-4"></p>
            </div>

            <button onclick="startGame()" class="w-full bg-slate-900 text-white font-bold py-4 rounded-xl shadow-lg active:scale-95 transition-all">
                确 定
            </button>
        </div>
    </div>

    <!-- 游戏页 -->
    <div id="gamePage" class="page-section hidden-page items-center justify-start pt-10 px-4">
        <div class="w-full max-w-[500px] flex justify-between items-center mb-4 px-1 mx-auto">
            <button onclick="backToHome()" class="text-xs font-bold text-slate-500 uppercase tracking-wider hover:text-slate-800">
                &larr; 返回
            </button>
            <div class="font-mono font-bold text-lg text-indigo-600" id="stepCount">0</div>
        </div>

        <div id="gameBoardContainer" class="w-full max-w-[500px] mx-auto pb-10">
            <div id="gameBoard"></div>
            
            <p class="mt-8 text-center text-xs text-slate-400 max-w-xs mx-auto">
                拖动组块。被覆盖的切片将优先保持组结构移动，无法整体移动时降序重排。
            </p>
        </div>
    </div>

    <!-- 胜利弹窗 -->
    <div id="winModal" class="fixed inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-sm hidden">
        <div class="bg-white p-6 rounded-2xl shadow-2xl text-center max-w-sm mx-4 celebrate-modal w-full">
            <h2 class="text-3xl font-black text-slate-800 mb-4">COMPLETE!</h2>
            
            <div class="w-full rounded-lg overflow-hidden mb-6 border border-slate-200 shadow-inner bg-slate-100 flex items-center justify-center">
                <img id="winImage" class="max-w-full max-h-[50vh] object-contain" src="" />
            </div>

            <button onclick="resetGame()" class="w-full bg-indigo-600 text-white font-bold py-3 rounded-xl hover:bg-indigo-700 transition-colors">
                再来一次
            </button>
        </div>
    </div>

    <canvas id="confetti" class="fixed inset-0 pointer-events-none z-[60]"></canvas>

    <script>
        // ================= 状态管理 =================
        let gridSize = 3;
        let imgUrl = document.getElementById('previewThumb').src;
        let currentImgRatio = 1;
        let boardState = [];
        let steps = 0;
        let isGameActive = false;

        // 拖拽状态
        let isDragging = false;
        let dragGroup = [];
        let dragStartPos = { x: 0, y: 0 };
        let dragStartCell = { r: 0, c: 0 };

        // DOM
        const gameBoard = document.getElementById('gameBoard');
        const homePage = document.getElementById('homePage');
        const gamePage = document.getElementById('gamePage');
        const stepDisplay = document.getElementById('stepCount');
        const winModal = document.getElementById('winModal');
        const winImage = document.getElementById('winImage');
        const imgRatioInfo = document.getElementById('imgRatioInfo');

        // ================= 初始化与图片处理 =================
        
        window.onload = () => {
            preloadImage(imgUrl);
        };

        function selectMode(n) {
            gridSize = n;
            document.querySelectorAll('.mode-btn').forEach(btn => {
                const size = parseInt(btn.dataset.size);
                if (size === n) {
                    btn.className = "mode-btn ring-2 ring-indigo-500 bg-indigo-50 text-indigo-700 py-3 rounded-lg text-sm font-bold";
                } else {
                    btn.className = "mode-btn border border-slate-200 text-slate-600 hover:bg-slate-50 py-3 rounded-lg text-sm font-medium";
                }
            });
        }

        document.getElementById('imageInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (evt) => {
                    const res = evt.target.result;
                    preloadImage(res);
                }
                reader.readAsDataURL(file);
            }
        });

        function preloadImage(src) {
            const img = new Image();
            img.onload = () => {
                currentImgRatio = img.width / img.height;
                imgUrl = src;
                document.getElementById('previewThumb').src = src;
                imgRatioInfo.innerText = `检测到尺寸: ${img.width}x${img.height} (比例 ${currentImgRatio.toFixed(2)})`;
            };
            img.src = src;
        }

        function startGame() {
            steps = 0;
            stepDisplay.innerText = "0";
            
            const total = gridSize * gridSize;
            boardState = Array.from({length: total}, (_, i) => i);
            
            for (let i = total - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [boardState[i], boardState[j]] = [boardState[j], boardState[i]];
            }

            renderBoard();

            homePage.classList.remove('active-page');
            homePage.classList.add('hidden-page');
            gamePage.classList.remove('hidden-page');
            gamePage.classList.add('active-page');
            
            isGameActive = true;
            winModal.classList.add('hidden');
        }

        function backToHome() {
            isGameActive = false;
            gamePage.classList.remove('active-page');
            gamePage.classList.add('hidden-page');
            homePage.classList.remove('hidden-page');
            homePage.classList.add('active-page');
        }

        function resetGame() {
            winModal.classList.add('hidden');
            startGame();
        }

        // ================= 核心：视觉渲染 =================
        
        function hasConnection(idx, dir) {
            const r = Math.floor(idx / gridSize);
            const c = idx % gridSize;
            const val = boardState[idx];

            let nr = r, nc = c;
            if (dir === 'up') nr--;
            else if (dir === 'down') nr++;
            else if (dir === 'left') nc--;
            else if (dir === 'right') nc++;

            if (nr < 0 || nr >= gridSize || nc < 0 || nc >= gridSize) return false;

            const nIdx = nr * gridSize + nc;
            const nVal = boardState[nIdx];

            if (dir === 'up' && nVal === val - gridSize) return true;
            if (dir === 'down' && nVal === val + gridSize) return true;
            
            const correctCol = val % gridSize;
            if (dir === 'left' && nVal === val - 1 && correctCol > 0) return true;
            if (dir === 'right' && nVal === val + 1 && correctCol < gridSize - 1) return true;

            return false;
        }

        function renderBoard() {
            gameBoard.innerHTML = '';
            
            const containerWidth = gameBoard.clientWidth;
            const availableWidth = containerWidth - 2;
            const availableHeight = availableWidth / currentImgRatio;

            gameBoard.style.height = `${availableHeight + 2}px`;

            const cellWidth = availableWidth / gridSize;
            const cellHeight = availableHeight / gridSize;

            boardState.forEach((val, idx) => {
                const r = Math.floor(idx / gridSize);
                const c = idx % gridSize;
                
                const tile = document.createElement('div');
                tile.className = 'tile';
                tile.dataset.val = val;

                const connectedUp = hasConnection(idx, 'up');
                const connectedDown = hasConnection(idx, 'down');
                const connectedLeft = hasConnection(idx, 'left');
                const connectedRight = hasConnection(idx, 'right');

                const mt = connectedUp ? 0 : 1;
                const mb = connectedDown ? 0 : 1;
                const ml = connectedLeft ? 0 : 1;
                const mr = connectedRight ? 0 : 1;

                const baseLeft = c * cellWidth;
                const baseTop = r * cellHeight;

                const actualLeft = baseLeft + ml;
                const actualTop = baseTop + mt;

                const actualWidth = cellWidth - ml - mr;
                const actualHeight = cellHeight - mt - mb;

                tile.style.width = `${actualWidth}px`;
                tile.style.height = `${actualHeight}px`;
                tile.style.transform = `translate(${actualLeft}px, ${actualTop}px)`;

                const correctR = Math.floor(val / gridSize);
                const correctC = val % gridSize;
                
                const bgOriginX = correctC * cellWidth;
                const bgOriginY = correctR * cellHeight;

                const bgPosX = -(bgOriginX + ml);
                const bgPosY = -(bgOriginY + mt);

                const totalBgWidth = gridSize * cellWidth;
                const totalBgHeight = gridSize * cellHeight;

                tile.style.backgroundImage = `url('${imgUrl}')`;
                tile.style.backgroundSize = `${totalBgWidth}px ${totalBgHeight}px`;
                tile.style.backgroundPosition = `${bgPosX}px ${bgPosY}px`;
                
                gameBoard.appendChild(tile);
            });
        }
        
        window.addEventListener('resize', () => { if (isGameActive) renderBoard(); });

        // ================= 组检测 =================
        function getConnectedGroup(startR, startC) {
            const visited = new Set();
            const group = [];
            const queue = [{r: startR, c: startC}];
            
            const startIdx = startR * gridSize + startC;
            const startVal = boardState[startIdx];
            
            visited.add(`${startR},${startC}`);
            group.push({r: startR, c: startC, val: startVal});

            let head = 0;
            while(head < group.length) {
                const curr = group[head++];
                const cIdx = curr.r * gridSize + curr.c;
                
                const dirs = [
                    {d: 'up', dr: -1, dc: 0},
                    {d: 'down', dr: 1, dc: 0},
                    {d: 'left', dr: 0, dc: -1},
                    {d: 'right', dr: 0, dc: 1}
                ];

                for (let dir of dirs) {
                    const nr = curr.r + dir.dr;
                    const nc = curr.c + dir.dc;

                    if (hasConnection(cIdx, dir.d) && !visited.has(`${nr},${nc}`)) {
                        const nIdx = nr * gridSize + nc;
                        visited.add(`${nr},${nc}`);
                        queue.push({r: nr, c: nc});
                        group.push({r: nr, c: nc, val: boardState[nIdx]});
                    }
                }
            }
            return group;
        }

        // ================= 移动核心：完全重写，修复覆盖组丢失bug =================
        function applyMove(group, dR, dC) {
            // ---- 1. 计算基础坐标集合 ----
            const S_coords = [];          // 拖动组原始位置
            const T_coords = [];          // 拖动组目标位置
            const setS = new Set();
            const setT = new Set();

            group.forEach(item => {
                S_coords.push({r: item.r, c: item.c});
                setS.add(`${item.r},${item.c}`);

                const nr = item.r + dR;
                const nc = item.c + dC;
                T_coords.push({r: nr, c: nc, val: item.val});
                setT.add(`${nr},${nc}`);
            });

            // ---- 2. 被覆盖的位置 O (T中不在S的位置) ----
            const O_coords = [];
            T_coords.forEach(item => {
                const key = `${item.r},${item.c}`;
                if (!setS.has(key)) {
                    O_coords.push({r: item.r, c: item.c});
                }
            });

            // ---- 3. 空出的位置 U (S中不在T的位置) ----
            const U_coords = [];
            S_coords.forEach(item => {
                const key = `${item.r},${item.c}`;
                if (!setT.has(key)) {
                    U_coords.push({r: item.r, c: item.c});
                }
            });

            // ---- 4. 构造新棋盘（初始为当前棋盘副本） ----
            const newBoard = [...boardState];

            // ---- 5. 第一步：将拖动组放置到目标位置 ----
            T_coords.forEach(item => {
                const idx = item.r * gridSize + item.c;
                newBoard[idx] = item.val;
            });

            // ---- 6. 处理被覆盖的格子：它们需要被重新安置到空位U中 ----
            
            // 剩余待处理的覆盖格子（初始为所有O_coords）
            let remainingO = O_coords.map(coord => ({r: coord.r, c: coord.c}));
            // 剩余可用空位（初始为所有U_coords）
            let remainingU = U_coords.map(coord => ({r: coord.r, c: coord.c}));

            // ---- 6.1 识别O_coords中的连接组 ----
            const visited = new Set();
            const O_groups = [];
            
            remainingO.forEach(coord => {
                const key = `${coord.r},${coord.c}`;
                if (!visited.has(key)) {
                    // 注意：这里要从当前棋盘状态 boardState 中找连接组
                    const groupCells = getConnectedGroup(coord.r, coord.c);
                    // 只保留那些在 remainingO 中的格子（因为被覆盖的格子才需要移动）
                    const filteredGroup = groupCells.filter(cell => 
                        remainingO.some(o => o.r === cell.r && o.c === cell.c)
                    );
                    if (filteredGroup.length > 0) {
                        filteredGroup.forEach(cell => visited.add(`${cell.r},${cell.c}`));
                        O_groups.push({
                            cells: filteredGroup,
                            minR: Math.min(...filteredGroup.map(g => g.r)),
                            minC: Math.min(...filteredGroup.map(g => g.c))
                        });
                    }
                }
            });

            // 按组大小降序（大组优先整体移动）
            O_groups.sort((a, b) => b.cells.length - a.cells.length);

            // ---- 6.2 尝试整体移动每个组 ----
            O_groups.forEach(groupInfo => {
                const groupCells = groupInfo.cells;
                const size = groupCells.length;
                
                // 如果剩余空位不足，无法整体移动
                if (remainingU.length < size) return;

                // 寻找最佳的偏移量：使得组内所有格子移动后都落在剩余空位中
                // 简单策略：用剩余空位的第一个格子作为组的左上角对齐点
                const anchor = remainingU[0];
                const offsetR = anchor.r - groupInfo.minR;
                const offsetC = anchor.c - groupInfo.minC;

                // 检查组内所有格子移动后是否都在remainingU中，且不与其他已移动组冲突
                let canMove = true;
                const targetPositions = [];
                
                for (let cell of groupCells) {
                    const nr = cell.r + offsetR;
                    const nc = cell.c + offsetC;
                    // 必须在剩余空位列表中
                    const found = remainingU.some(u => u.r === nr && u.c === nc);
                    if (!found) {
                        canMove = false;
                        break;
                    }
                    targetPositions.push({r: nr, c: nc});
                }

                if (canMove) {
                    // 执行整体移动
                    for (let i = 0; i < groupCells.length; i++) {
                        const cell = groupCells[i];
                        const target = targetPositions[i];
                        const targetIdx = target.r * gridSize + target.c;
                        // 将被覆盖组的值赋到空位
                        newBoard[targetIdx] = boardState[cell.r * gridSize + cell.c];
                        
                        // 从remainingO中移除这个被移动的格子
                        const oIndex = remainingO.findIndex(o => o.r === cell.r && o.c === cell.c);
                        if (oIndex !== -1) remainingO.splice(oIndex, 1);
                        // 从remainingU中移除这个被占用的空位
                        const uIndex = remainingU.findIndex(u => u.r === target.r && u.c === target.c);
                        if (uIndex !== -1) remainingU.splice(uIndex, 1);
                    }
                }
            });

            // ---- 6.3 剩余的被覆盖格子（无法整体移动）降序重排 ----
            if (remainingO.length > 0) {
                // 收集这些格子当前的值
                const vals = remainingO.map(coord => {
                    const idx = coord.r * gridSize + coord.c;
                    return boardState[idx];
                });
                // 降序排序
                vals.sort((a, b) => b - a);
                // 剩余空位按行优先排序
                remainingU.sort((a, b) => {
                    if (a.r !== b.r) return a.r - b.r;
                    return a.c - b.c;
                });

                // 将降序值依次填入剩余空位
                for (let i = 0; i < Math.min(vals.length, remainingU.length); i++) {
                    const targetIdx = remainingU[i].r * gridSize + remainingU[i].c;
                    newBoard[targetIdx] = vals[i];
                }
                // 注意：如果vals数量多于remainingU，理论上不会发生，因为O和U数量相等
                // 但为了安全，多余的值丢弃（它们原本的位置已被拖动组占据）
            }

            // ---- 7. 更新全局状态 ----
            boardState = newBoard;
            renderBoard();
            checkWin();
        }

        function checkWin() {
            let win = true;
            for (let i = 0; i < boardState.length; i++) {
                if (boardState[i] !== i) {
                    win = false;
                    break;
            }
            }
            if (win) {
                setTimeout(() => {
                    winImage.src = imgUrl;
                    document.getElementById('winModal').classList.remove('hidden');
                    fireConfetti();
                }, 300);
            }
        }

        // ================= 交互处理 =================
        
        function getCellFromPx(x, y) {
            const rect = gameBoard.getBoundingClientRect();
            const availW = rect.width - 2;
            const availH = rect.height - 2;
            const cellW = availW / gridSize;
            const cellH = availH / gridSize;
            const r = Math.floor((y - rect.top - 1) / cellH);
            const c = Math.floor((x - rect.left - 1) / cellW);
            return { r, c, cellW, cellH };
        }

        gameBoard.addEventListener('pointerdown', e => {
            if (!isGameActive) return;
            const target = e.target.closest('.tile');
            if (!target) return;
            e.preventDefault();

            const { r, c } = getCellFromPx(e.clientX, e.clientY);
            if (r < 0 || r >= gridSize || c < 0 || c >= gridSize) return;

            dragGroup = getConnectedGroup(r, c);
            isDragging = true;
            dragStartPos = { x: e.clientX, y: e.clientY };
            dragStartCell = { r, c };

            dragGroup.forEach(item => {
                const el = document.querySelector(`.tile[data-val='${item.val}']`);
                if(el) {
                    el.classList.add('is-dragging');
                    if (!el.dataset.startX) {
                         const style = window.getComputedStyle(el);
                         const matrix = new DOMMatrix(style.transform);
                         el.dataset.startX = matrix.m41;
                         el.dataset.startY = matrix.m42;
                    }
                }
            });
        });

        window.addEventListener('pointermove', e => {
            if (!isDragging) return;
            e.preventDefault();

            const dx = e.clientX - dragStartPos.x;
            const dy = e.clientY - dragStartPos.y;

            dragGroup.forEach(item => {
                const el = document.querySelector(`.tile[data-val='${item.val}']`);
                if (el && el.dataset.startX) {
                    const newX = parseFloat(el.dataset.startX) + dx;
                    const newY = parseFloat(el.dataset.startY) + dy;
                    el.style.transform = `translate(${newX}px, ${newY}px) scale(1.02)`;
                }
            });

            const { r: currR, c: currC, cellW, cellH } = getCellFromPx(e.clientX, e.clientY);
            const dR = currR - dragStartCell.r;
            const dC = currC - dragStartCell.c;

            let isValid = (dR !== 0 || dC !== 0);
            if (isValid) {
                for (let item of dragGroup) {
                    const nr = item.r + dR;
                    const nc = item.c + dC;
                    if (nr < 0 || nr >= gridSize || nc < 0 || nc >= gridSize) {
                        isValid = false;
                        break;
                    }
                }
            }

            document.querySelectorAll('.ghost-tile').forEach(el => el.remove());
            if (isValid) {
                dragGroup.forEach(item => {
                    const nr = item.r + dR;
                    const nc = item.c + dC;
                    const ghost = document.createElement('div');
                    ghost.className = 'ghost-tile';
                    ghost.style.width = `${cellW - 2}px`;
                    ghost.style.height = `${cellH - 2}px`;
                    ghost.style.transform = `translate(${nc * cellW + 1}px, ${nr * cellH + 1}px)`;
                    gameBoard.appendChild(ghost);
                });
            }
        });

        window.addEventListener('pointerup', e => {
            if (!isDragging) return;

            document.querySelectorAll('.tile').forEach(el => {
                el.classList.remove('is-dragging');
                delete el.dataset.startX;
                delete el.dataset.startY;
                el.style.transform = '';
            });
            document.querySelectorAll('.ghost-tile').forEach(el => el.remove());

            const { r: currR, c: currC } = getCellFromPx(e.clientX, e.clientY);
            const dR = currR - dragStartCell.r;
            const dC = currC - dragStartCell.c;

            let isValid = (dR !== 0 || dC !== 0);
            if (isValid) {
                for (let item of dragGroup) {
                    const nr = item.r + dR;
                    const nc = item.c + dC;
                    if (nr < 0 || nr >= gridSize || nc < 0 || nc >= gridSize) {
                        isValid = false;
                        break;
                    }
                }
            }

            if (isValid) {
                applyMove(dragGroup, dR, dC);
                steps++;
                stepDisplay.innerText = steps;
            } else {
                renderBoard();
            }

            isDragging = false;
            dragGroup = [];
        });

        // ================= 庆祝特效 =================
        function fireConfetti() {
            const canvas = document.getElementById('confetti');
            const ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            const particles = [];
            const colors = ['#4f46e5', '#ec4899', '#10b981', '#f59e0b', '#8b5cf6'];
            
            for(let i=0; i<200; i++) {
                particles.push({
                    x: canvas.width / 2,
                    y: canvas.height / 2,
                    vx: (Math.random() - 0.5) * 20,
                    vy: (Math.random() - 0.5) * 20 - 5,
                    color: colors[Math.floor(Math.random() * colors.length)],
                    size: Math.random() * 8 + 2,
                    life: 150
                });
            }
            
            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                let active = false;
                
                particles.forEach(p => {
                    if(p.life > 0) {
                        active = true;
                        p.x += p.vx;
                        p.y += p.vy;
                        p.vy += 0.4;
                        p.life--;
                        p.size *= 0.96;
                        
                        ctx.fillStyle = p.color;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
                
                if(active && !winModal.classList.contains('hidden')) {
                    requestAnimationFrame(animate);
                } else {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            }
            animate();
        }
    </script>
</body>
</html>