<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>自适应拼图游戏</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            overscroll-behavior: none;
            user-select: none;
            -webkit-user-select: none;
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
        }

        .page-section {
            transition: opacity 0.3s ease, transform 0.3s ease;
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            display: flex;
            flex-direction: column;
            background-color: #f1f5f9;
            overflow-y: auto; /* 允许垂直滚动以适应长图 */
        }

        .hidden-page {
            opacity: 0;
            pointer-events: none;
            z-index: -1;
            transform: scale(0.98);
            position: absolute; /* 确保隐藏时不占位 */
        }

        .active-page {
            opacity: 1;
            pointer-events: auto;
            z-index: 10;
            transform: scale(1);
        }

        #gameBoard {
            /* 修改：移除 aspect-ratio，改为相对定位，高度由JS控制 */
            position: relative;
            width: 100%;
            max-width: 500px;
            margin: 0 auto;
            background-color: white; 
            padding: 1px; 
            border-radius: 4px;
            touch-action: none;
            box-sizing: border-box;
            transition: height 0.3s ease; /* 高度变化动画 */
        }

        .tile {
            position: absolute;
            transition: transform 0.2s cubic-bezier(0.2, 0.8, 0.2, 1);
            background-repeat: no-repeat;
            z-index: 10;
            box-sizing: border-box;
        }

        .tile.is-dragging {
            z-index: 50;
            transition: none;
            box-shadow: 0 10px 25px rgba(0,0,0,0.4);
            transform: scale(1.02);
            opacity: 0.95;
            filter: brightness(1.1);
        }

        .ghost-tile {
            position: absolute;
            background-color: rgba(99, 102, 241, 0.2);
            border: 2px dashed #6366f1;
            z-index: 5;
            pointer-events: none;
        }

        @keyframes pop {
            0% { transform: scale(0.8); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }
        .celebrate-modal {
            animation: pop 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
    </style>
</head>
<body class="h-screen w-screen overflow-hidden text-slate-800">

    <!-- 设置页 -->
    <div id="homePage" class="page-section active-page items-center justify-center p-6">
        <div class="w-full max-w-md bg-white rounded-2xl shadow-xl p-8 my-auto">
            <h1 class="text-2xl font-black text-center mb-1">STRICT PUZZLE</h1>
            <p class="text-center text-slate-400 text-xs mb-8">自适应长宽比 · 智能间隙</p>

            <div class="mb-6">
                <label class="text-xs font-bold text-slate-400 uppercase tracking-wider mb-2 block">Grid Size</label>
                <div class="grid grid-cols-3 gap-3">
                    <button onclick="selectMode(3)" class="mode-btn ring-2 ring-indigo-500 bg-indigo-50 text-indigo-700 py-3 rounded-lg text-sm font-bold" data-size="3">3 x 3</button>
                    <button onclick="selectMode(4)" class="mode-btn border border-slate-200 text-slate-600 hover:bg-slate-50 py-3 rounded-lg text-sm font-medium" data-size="4">4 x 4</button>
                    <button onclick="selectMode(5)" class="mode-btn border border-slate-200 text-slate-600 hover:bg-slate-50 py-3 rounded-lg text-sm font-medium" data-size="5">5 x 5</button>
                </div>
            </div>

            <div class="mb-8">
                <label class="text-xs font-bold text-slate-400 uppercase tracking-wider mb-2 block">Image</label>
                <label class="relative block w-full aspect-video rounded-lg overflow-hidden cursor-pointer group bg-slate-100 border-2 border-dashed border-slate-300 flex items-center justify-center">
                    <!-- 预览图也设为 object-contain 以便查看全貌，或者保持 cover 视情况而定 -->
                    <img id="previewThumb" class="w-full h-full object-cover" src="https://images.unsplash.com/photo-1579546929518-9e396f3cc809?ixlib=rb-4.0.3&auto=format&fit=crop&w=1000&q=80" />
                    <div class="absolute inset-0 bg-black/40 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity">
                        <span class="text-white text-xs font-bold">更换图片</span>
                    </div>
                    <input id="imageInput" type="file" class="hidden" accept="image/*" />
                </label>
                <p id="imgRatioInfo" class="text-center text-[10px] text-slate-400 mt-2 h-4"></p>
            </div>

            <button onclick="startGame()" class="w-full bg-slate-900 text-white font-bold py-4 rounded-xl shadow-lg active:scale-95 transition-all">
                确 定
            </button>
        </div>
    </div>

    <!-- 游戏页 -->
    <div id="gamePage" class="page-section hidden-page items-center justify-start pt-10 px-4">
        <div class="w-full max-w-[500px] flex justify-between items-center mb-4 px-1 mx-auto">
            <button onclick="backToHome()" class="text-xs font-bold text-slate-500 uppercase tracking-wider hover:text-slate-800">
                &larr; 返回
            </button>
            <div class="font-mono font-bold text-lg text-indigo-600" id="stepCount">0</div>
        </div>

        <div id="gameBoardContainer" class="w-full max-w-[500px] mx-auto pb-10">
            <div id="gameBoard"></div>
            
            <p class="mt-8 text-center text-xs text-slate-400 max-w-xs mx-auto">
                拖动组块。被覆盖的切片将按数值降序填入释放的空间。
            </p>
        </div>
    </div>

    <!-- 胜利弹窗 -->
    <div id="winModal" class="fixed inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-sm hidden">
        <div class="bg-white p-6 rounded-2xl shadow-2xl text-center max-w-sm mx-4 celebrate-modal w-full">
            <h2 class="text-3xl font-black text-slate-800 mb-4">COMPLETE!</h2>
            
            <div class="w-full rounded-lg overflow-hidden mb-6 border border-slate-200 shadow-inner bg-slate-100 flex items-center justify-center">
                <!-- 结果图不强制正方形，保持原比例 -->
                <img id="winImage" class="max-w-full max-h-[50vh] object-contain" src="" />
            </div>

            <button onclick="resetGame()" class="w-full bg-indigo-600 text-white font-bold py-3 rounded-xl hover:bg-indigo-700 transition-colors">
                再来一次
            </button>
        </div>
    </div>

    <canvas id="confetti" class="fixed inset-0 pointer-events-none z-[60]"></canvas>

    <script>
        // ================= 状态管理 =================
        let gridSize = 3;
        let imgUrl = document.getElementById('previewThumb').src;
        let currentImgRatio = 1; // 修改：记录图片宽高比 (width / height)
        let boardState = []; 
        let steps = 0;
        let isGameActive = false;

        // 拖拽状态
        let isDragging = false;
        let dragGroup = []; 
        let dragStartPos = { x: 0, y: 0 };
        let dragStartCell = { r: 0, c: 0 };

        // DOM
        const gameBoard = document.getElementById('gameBoard');
        const homePage = document.getElementById('homePage');
        const gamePage = document.getElementById('gamePage');
        const stepDisplay = document.getElementById('stepCount');
        const winModal = document.getElementById('winModal');
        const winImage = document.getElementById('winImage');
        const imgRatioInfo = document.getElementById('imgRatioInfo');

        // ================= 初始化与图片处理 =================
        
        // 预加载默认图片以获取比例
        window.onload = () => {
            preloadImage(imgUrl);
        };

        function selectMode(n) {
            gridSize = n;
            document.querySelectorAll('.mode-btn').forEach(btn => {
                const size = parseInt(btn.dataset.size);
                if (size === n) {
                    btn.className = "mode-btn ring-2 ring-indigo-500 bg-indigo-50 text-indigo-700 py-3 rounded-lg text-sm font-bold";
                } else {
                    btn.className = "mode-btn border border-slate-200 text-slate-600 hover:bg-slate-50 py-3 rounded-lg text-sm font-medium";
                }
            });
        }

        document.getElementById('imageInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (evt) => {
                    const res = evt.target.result;
                    preloadImage(res); // 加载并计算比例
                }
                reader.readAsDataURL(file);
            }
        });

        // 修改：新增图片预加载函数，计算宽高比
        function preloadImage(src) {
            const img = new Image();
            img.onload = () => {
                currentImgRatio = img.width / img.height;
                imgUrl = src;
                document.getElementById('previewThumb').src = src;
                imgRatioInfo.innerText = `检测到尺寸: ${img.width}x${img.height} (比例 ${currentImgRatio.toFixed(2)})`;
            };
            img.src = src;
        }

        function startGame() {
            steps = 0;
            stepDisplay.innerText = "0";
            
            const total = gridSize * gridSize;
            boardState = Array.from({length: total}, (_, i) => i);
            
            // 随机打乱
            for (let i = total - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [boardState[i], boardState[j]] = [boardState[j], boardState[i]];
            }

            // 在切换页面前渲染，确保尺寸计算正确
            renderBoard();

            homePage.classList.remove('active-page');
            homePage.classList.add('hidden-page');
            gamePage.classList.remove('hidden-page');
            gamePage.classList.add('active-page');
            
            isGameActive = true;
            winModal.classList.add('hidden');
        }

        function backToHome() {
            isGameActive = false;
            gamePage.classList.remove('active-page');
            gamePage.classList.add('hidden-page');
            homePage.classList.remove('hidden-page');
            homePage.classList.add('active-page');
        }

        function resetGame() {
            winModal.classList.add('hidden');
            startGame();
        }

        // ================= 核心：视觉渲染 (自适应版) =================
        
        function hasConnection(idx, dir) {
            const r = Math.floor(idx / gridSize);
            const c = idx % gridSize;
            const val = boardState[idx];

            let nr = r, nc = c;
            if (dir === 'up') nr--;
            else if (dir === 'down') nr++;
            else if (dir === 'left') nc--;
            else if (dir === 'right') nc++;

            if (nr < 0 || nr >= gridSize || nc < 0 || nc >= gridSize) return false;

            const nIdx = nr * gridSize + nc;
            const nVal = boardState[nIdx];

            if (dir === 'up' && nVal === val - gridSize) return true;
            if (dir === 'down' && nVal === val + gridSize) return true;
            
            const correctCol = val % gridSize;
            if (dir === 'left' && nVal === val - 1 && correctCol > 0) return true;
            if (dir === 'right' && nVal === val + 1 && correctCol < gridSize - 1) return true;

            return false;
        }

        function renderBoard() {
            gameBoard.innerHTML = '';
            
            const containerWidth = gameBoard.clientWidth;
            // 减去外围 padding 2px
            const availableWidth = containerWidth - 2; 
            
            // 修改：根据图片比例计算可用高度
            // height = width / ratio
            const availableHeight = availableWidth / currentImgRatio;

            // 设置游戏板高度
            gameBoard.style.height = `${availableHeight + 2}px`; // +2 padding

            // 分别计算单元格的宽和高
            const cellWidth = availableWidth / gridSize; 
            const cellHeight = availableHeight / gridSize;

            boardState.forEach((val, idx) => {
                const r = Math.floor(idx / gridSize);
                const c = idx % gridSize;
                
                const tile = document.createElement('div');
                tile.className = 'tile';
                tile.dataset.val = val;

                // 间隙计算 (保持不变)
                const connectedUp = hasConnection(idx, 'up');
                const connectedDown = hasConnection(idx, 'down');
                const connectedLeft = hasConnection(idx, 'left');
                const connectedRight = hasConnection(idx, 'right');

                const mt = connectedUp ? 0 : 1;
                const mb = connectedDown ? 0 : 1;
                const ml = connectedLeft ? 0 : 1;
                const mr = connectedRight ? 0 : 1;

                // 2. 计算实际宽高与位置 (现在使用 cellWidth 和 cellHeight)
                const baseLeft = c * cellWidth;
                const baseTop = r * cellHeight;

                const actualLeft = baseLeft + ml;
                const actualTop = baseTop + mt;

                const actualWidth = cellWidth - ml - mr;
                const actualHeight = cellHeight - mt - mb;

                tile.style.width = `${actualWidth}px`;
                tile.style.height = `${actualHeight}px`;
                tile.style.transform = `translate(${actualLeft}px, ${actualTop}px)`;

                // 3. 背景图计算 (支持长方形)
                const correctR = Math.floor(val / gridSize);
                const correctC = val % gridSize;
                
                // 图片在逻辑网格中的原点
                const bgOriginX = correctC * cellWidth;
                const bgOriginY = correctR * cellHeight;

                const bgPosX = -(bgOriginX + ml);
                const bgPosY = -(bgOriginY + mt);

                // 背景总尺寸 (宽和高独立计算)
                const totalBgWidth = gridSize * cellWidth;
                const totalBgHeight = gridSize * cellHeight;

                tile.style.backgroundImage = `url('${imgUrl}')`;
                tile.style.backgroundSize = `${totalBgWidth}px ${totalBgHeight}px`;
                tile.style.backgroundPosition = `${bgPosX}px ${bgPosY}px`;
                
                gameBoard.appendChild(tile);
            });
        }
        
        window.addEventListener('resize', () => { if (isGameActive) renderBoard(); });

        // ================= 组检测 (逻辑不变) =================
        function getConnectedGroup(startR, startC) {
            const visited = new Set();
            const group = [];
            const queue = [{r: startR, c: startC}];
            
            const startIdx = startR * gridSize + startC;
            const startVal = boardState[startIdx];
            
            visited.add(`${startR},${startC}`);
            group.push({r: startR, c: startC, val: startVal});

            let head = 0;
            while(head < group.length) {
                const curr = group[head++];
                const cIdx = curr.r * gridSize + curr.c;
                
                const dirs = [
                    {d: 'up', dr: -1, dc: 0},
                    {d: 'down', dr: 1, dc: 0},
                    {d: 'left', dr: 0, dc: -1},
                    {d: 'right', dr: 0, dc: 1}
                ];

                for (let dir of dirs) {
                    const nr = curr.r + dir.dr;
                    const nc = curr.c + dir.dc;

                    if (hasConnection(cIdx, dir.d) && !visited.has(`${nr},${nc}`)) {
                        const nIdx = nr * gridSize + nc;
                        visited.add(`${nr},${nc}`);
                        queue.push({r: nr, c: nc});
                        group.push({r: nr, c: nc, val: boardState[nIdx]});
                    }
                }
            }
            return group;
        }

        // ================= 移动核心 (逻辑不变) =================
        function applyMove(group, dR, dC) {
            const S_coords = [];
            const T_coords = [];
            const setS_keys = new Set();
            const setT_keys = new Set();

            group.forEach(item => {
                S_coords.push({r: item.r, c: item.c});
                setS_keys.add(`${item.r},${item.c}`);

                const nr = item.r + dR;
                const nc = item.c + dC;
                T_coords.push({r: nr, c: nc, val: item.val});
                setT_keys.add(`${nr},${nc}`);
            });

            const O_coords = [];
            T_coords.forEach(item => {
                const key = `${item.r},${item.c}`;
                if (!setS_keys.has(key)) O_coords.push({r: item.r, c: item.c});
            });

            const U_coords = [];
            S_coords.forEach(item => {
                const key = `${item.r},${item.c}`;
                if (!setT_keys.has(key)) U_coords.push({r: item.r, c: item.c});
            });

            const L_vals = [];
            O_coords.forEach(coord => {
                const idx = coord.r * gridSize + coord.c;
                L_vals.push(boardState[idx]);
            });

            L_vals.sort((a, b) => b - a);

            const C_coords = U_coords.sort((a, b) => {
                if (a.r !== b.r) return a.r - b.r;
                return a.c - b.c;
            });

            const newBoard = [...boardState];

            T_coords.forEach(item => {
                const idx = item.r * gridSize + item.c;
                newBoard[idx] = item.val;
            });

            for (let i = 0; i < L_vals.length; i++) {
                const targetCoord = C_coords[i];
                const targetIdx = targetCoord.r * gridSize + targetCoord.c;
                newBoard[targetIdx] = L_vals[i];
            }

            boardState = newBoard;
            renderBoard();
            checkWin();
        }

        function checkWin() {
            let win = true;
            for (let i = 0; i < boardState.length; i++) {
                if (boardState[i] !== i) {
                    win = false;
                    break;
                }
            }
            if (win) {
                setTimeout(() => {
                    winImage.src = imgUrl;
                    document.getElementById('winModal').classList.remove('hidden');
                    fireConfetti();
                }, 300);
            }
        }

        // ================= 交互处理 (自适应计算) =================
        
        function getCellFromPx(x, y) {
            const rect = gameBoard.getBoundingClientRect();
            // 减去 padding
            const availW = rect.width - 2;
            const availH = rect.height - 2;
            
            // 修改：使用分别的宽和高
            const cellW = availW / gridSize;
            const cellH = availH / gridSize;
            
            const r = Math.floor((y - rect.top - 1) / cellH);
            const c = Math.floor((x - rect.left - 1) / cellW);
            
            return { r, c, cellW, cellH }; // 返回尺寸供 ghost 使用
        }

        gameBoard.addEventListener('pointerdown', e => {
            if (!isGameActive) return;
            const target = e.target.closest('.tile');
            if (!target) return;
            e.preventDefault();

            const { r, c } = getCellFromPx(e.clientX, e.clientY);
            if (r < 0 || r >= gridSize || c < 0 || c >= gridSize) return;

            dragGroup = getConnectedGroup(r, c);
            isDragging = true;
            dragStartPos = { x: e.clientX, y: e.clientY };
            dragStartCell = { r, c };

            dragGroup.forEach(item => {
                const el = document.querySelector(`.tile[data-val='${item.val}']`);
                if(el) {
                    el.classList.add('is-dragging');
                    // 记录初始 transform 以便平滑拖拽
                    if (!el.dataset.startX) {
                         const style = window.getComputedStyle(el);
                         const matrix = new DOMMatrix(style.transform);
                         el.dataset.startX = matrix.m41;
                         el.dataset.startY = matrix.m42;
                    }
                }
            });
        });

        window.addEventListener('pointermove', e => {
            if (!isDragging) return;
            e.preventDefault();

            const dx = e.clientX - dragStartPos.x;
            const dy = e.clientY - dragStartPos.y;

            dragGroup.forEach(item => {
                const el = document.querySelector(`.tile[data-val='${item.val}']`);
                if (el && el.dataset.startX) {
                    const newX = parseFloat(el.dataset.startX) + dx;
                    const newY = parseFloat(el.dataset.startY) + dy;
                    el.style.transform = `translate(${newX}px, ${newY}px) scale(1.02)`;
                }
            });

            const { r: currR, c: currC, cellW, cellH } = getCellFromPx(e.clientX, e.clientY);
            const dR = currR - dragStartCell.r;
            const dC = currC - dragStartCell.c;

            let isValid = (dR !== 0 || dC !== 0);
            if (isValid) {
                for (let item of dragGroup) {
                    const nr = item.r + dR;
                    const nc = item.c + dC;
                    if (nr < 0 || nr >= gridSize || nc < 0 || nc >= gridSize) {
                        isValid = false;
                        break;
                    }
                }
            }

            document.querySelectorAll('.ghost-tile').forEach(el => el.remove());
            if (isValid) {
                dragGroup.forEach(item => {
                    const nr = item.r + dR;
                    const nc = item.c + dC;
                    const ghost = document.createElement('div');
                    ghost.className = 'ghost-tile';
                    // 修改：Ghost 大小适应长宽比
                    ghost.style.width = `${cellW - 2}px`;
                    ghost.style.height = `${cellH - 2}px`;
                    ghost.style.transform = `translate(${nc * cellW + 1}px, ${nr * cellH + 1}px)`;
                    gameBoard.appendChild(ghost);
                });
            }
        });

        window.addEventListener('pointerup', e => {
            if (!isDragging) return;

            document.querySelectorAll('.tile').forEach(el => {
                el.classList.remove('is-dragging');
                delete el.dataset.startX;
                delete el.dataset.startY;
                el.style.transform = ''; 
            });
            document.querySelectorAll('.ghost-tile').forEach(el => el.remove());

            const { r: currR, c: currC } = getCellFromPx(e.clientX, e.clientY);
            const dR = currR - dragStartCell.r;
            const dC = currC - dragStartCell.c;

            let isValid = (dR !== 0 || dC !== 0);
            if (isValid) {
                for (let item of dragGroup) {
                    const nr = item.r + dR;
                    const nc = item.c + dC;
                    if (nr < 0 || nr >= gridSize || nc < 0 || nc >= gridSize) {
                        isValid = false;
                        break;
                    }
                }
            }

            if (isValid) {
                applyMove(dragGroup, dR, dC);
                steps++;
                stepDisplay.innerText = steps;
            } else {
                renderBoard(); 
            }

            isDragging = false;
            dragGroup = [];
        });

        // ================= 庆祝特效 =================
        function fireConfetti() {
            const canvas = document.getElementById('confetti');
            const ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            const particles = [];
            const colors = ['#4f46e5', '#ec4899', '#10b981', '#f59e0b', '#8b5cf6'];
            
            for(let i=0; i<200; i++) {
                particles.push({
                    x: canvas.width / 2,
                    y: canvas.height / 2,
                    vx: (Math.random() - 0.5) * 20,
                    vy: (Math.random() - 0.5) * 20 - 5,
                    color: colors[Math.floor(Math.random() * colors.length)],
                    size: Math.random() * 8 + 2,
                    life: 150
                });
            }
            
            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                let active = false;
                
                particles.forEach(p => {
                    if(p.life > 0) {
                        active = true;
                        p.x += p.vx;
                        p.y += p.vy;
                        p.vy += 0.4;
                        p.life--;
                        p.size *= 0.96;
                        
                        ctx.fillStyle = p.color;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
                
                if(active && !winModal.classList.contains('hidden')) {
                    requestAnimationFrame(animate);
                } else {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            }
            animate();
        }
    </script>
</body>
</html>