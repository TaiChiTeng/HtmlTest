<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Helltaker - Sin Machine Perfected</title>
    <link href="https://fonts.googleapis.com/css2?family=Crimson+Text:wght@700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #0d0d0d;
            --ui-red: #ff0044;
            --ui-white: #e0e0e0;
            --ui-gold: #ffd700;
        }

        body {
            background-color: var(--bg-color);
            color: var(--ui-white);
            font-family: 'Crimson Text', serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
        }

        #game-wrapper {
            position: relative;
            width: 100%;
            max-width: 650px; 
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0 10px;
            box-sizing: border-box;
        }

        #top-bar {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            height: 30px;
        }

        .btn {
            background: transparent;
            color: #888;
            border: 2px solid #444;
            padding: 4px 10px;
            font-family: inherit;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            font-size: 12px;
            transition: all 0.2s;
            white-space: nowrap;
        }
        .btn:active { transform: scale(0.95); background: rgba(255,255,255,0.1); }
        .btn-restart { border-color: var(--ui-red); color: var(--ui-red); }
        .btn-levels { border-color: #fff; color: #fff; }

        #indicators-wrapper { display: flex; align-items: center; gap: 10px; }
        #info-indicator, #key-indicator {
            color: var(--ui-gold); font-size: 18px; display: none; align-items: center; gap: 5px;
            text-shadow: 0 0 5px rgba(255, 215, 0, 0.5); font-weight: bold;
        }
        #info-indicator.visible, #key-indicator.visible { display: flex; }

        #game-container {
            position: relative;
            width: 100%;
            height: 60vh;
            max-height: 600px;
            border: 4px solid #2a2a2a;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            background: #1a1a1a;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas { display: block; image-rendering: pixelated; }

        #ui-bar {
            margin-top: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .stat-box { font-size: 28px; letter-spacing: 2px; text-shadow: 2px 2px 0 #000; }
        .highlight { color: var(--ui-red); font-size: 36px; }
        .controls-hint { font-size: 14px; color: #666; opacity: 0.7; }

        #boss-hp-container {
            position: absolute; top: 10px; left: 10%; width: 80%; height: 10px; 
            background: #333; border: 2px solid #fff; display: none; z-index: 50;
        }
        #boss-hp-fill { height: 100%; background: var(--ui-red); width: 100%; transition: width 0.2s; }

        .modal-overlay {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.85); backdrop-filter: blur(4px);
            display: none; flex-direction: column; justify-content: center; align-items: center;
            z-index: 999; opacity: 0; transition: opacity 0.2s ease; padding: 20px;
        }
        .modal-overlay.show { opacity: 1; }

        .modal-box {
            background: #fff; color: #000; padding: 25px; border: 4px solid #000;
            text-align: center; width: auto; min-width: 200px; max-width: 90%;
            box-shadow: 0 0 30px rgba(255, 0, 68, 0.4);
            transform: scale(0.9); transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        .modal-overlay.show .modal-box { transform: scale(1); }

        .modal-title { font-size: 24px; color: var(--ui-red); display: block; margin-bottom: 15px; text-transform: uppercase; line-height: 1.2; }
        .modal-buttons { display: flex; justify-content: center; gap: 10px; margin-top: 20px; flex-wrap: wrap; }
        .btn-modal { border: 2px solid #000; background: #fff; color: #000; padding: 8px 16px; font-size: 16px; cursor: pointer; font-weight: bold; min-width: 60px; }
        .btn-primary { background: #000; color: #fff; }

        #level-list {
            display: flex; flex-wrap: nowrap; overflow-x: auto; gap: 12px; padding: 5px;
            margin: 0 auto; max-width: 280px; justify-content: flex-start;
            scrollbar-width: thin; scrollbar-color: var(--ui-red) #eee; -webkit-overflow-scrolling: touch;
        }
        .btn-level-select { flex: 0 0 auto; width: 50px; height: 50px; font-size: 20px; display: flex; align-items: center; justify-content: center; }

        .shake { animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both; }
        @keyframes shake {
            10%, 90% { transform: translate3d(-2px, 0, 0); }
            20%, 80% { transform: translate3d(4px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-6px, 0, 0); }
            40%, 60% { transform: translate3d(6px, 0, 0); }
        }
    </style>
</head>
<body>

<div id="game-wrapper">
    <div id="top-bar">
        <div style="display:flex; gap:10px; align-items:center;">
            <button class="btn btn-levels" id="btn-levels-ui">LEVELS</button>
            <div id="indicators-wrapper">
                <div id="key-indicator">üîë KEY</div>
                <div id="info-indicator"></div>
            </div>
        </div>
        <span style="color:#666; letter-spacing:1px; font-size:14px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width: 80px;" id="level-indicator">LVL I</span>
        <button class="btn btn-restart" id="btn-restart-ui">R</button>
    </div>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="boss-hp-container"><div id="boss-hp-fill"></div></div>
        
        <div id="modal-restart" class="modal-overlay"><div class="modal-box"><span class="modal-title">RESTART?</span><div class="modal-buttons"><button class="btn btn-modal btn-primary" id="btn-confirm">YES</button><button class="btn btn-modal" id="btn-cancel">NO</button></div></div></div>
        <div id="modal-levels" class="modal-overlay"><div class="modal-box"><span class="modal-title">SELECT LEVEL</span><div id="level-list"></div><div class="modal-buttons"><button class="btn btn-modal" id="btn-cancel-levels">CLOSE</button></div></div></div>
        <div id="modal-dialogue" class="modal-overlay"><div class="modal-box"><span class="modal-title" id="dia-title"></span><div id="dia-text" style="font-style:italic;margin-bottom:15px;font-size:14px;"></div><button class="btn btn-modal btn-primary" id="btn-next">NEXT</button></div></div>
    </div>

    <div id="ui-bar">
        <div class="stat-box" id="stat-container">WILL: <span id="moves-val" class="highlight">23</span></div>
        <div class="controls-hint">Swipe or Tap Arrows (Keyboard)</div>
    </div>
</div>

<script>
/**
 * Helltaker Perfected - ‰ºòÂåñÁâà
 * ÊîπËøõÂÜÖÂÆπÔºö
 * 1. Ê∑ªÂä†ÁºìÂä®ÂáΩÊï∞ËÆ©Âä®ÁîªÊõ¥Âπ≥Êªë
 * 2. ÂêåÊ≠•ÊâÄÊúâÂÖÉÁ¥†ÔºàÈìæÊù°„ÄÅÁ≤íÂ≠êÔºâÁöÑÊªöÂä®
 * 3. Ê∑ªÂä†ÊªöÂä®ÊåáÁ§∫Âô®
 * 4. ‰øÆÂ§çÁ≤íÂ≠êÁ≥ªÁªüÂÅèÁßª
 * 5. ‰ºòÂåñÁé©ÂÆ∂‰ΩçÁΩÆËÆ°ÁÆó
 */

// --- Êï∞ÊçÆ ---
const LEVELS = [
    {type:'PUZZLE',title:"LEVEL I",demonName:"Pandemonica",demonLine:"Coffee? I hope you brought some.",map:["888888888","888880088","880000088","880000888","800888888","800000088","800000008","888888888"],config:{cols:9,rows:8,maxMoves:23,heroStart:{r:6,c:6},girls:[{r:1,c:7}],rocks:[{r:1,c:2},{r:1,c:4},{r:2,c:2},{r:2,c:5}],mobs:[{r:4,c:3},{r:4,c:5},{r:5,c:4}],spikes:[],toggleSpikes:[],keys:[],locks:[]}},
    {type:'PUZZLE',title:"LEVEL II",demonName:"Modeus",demonLine:"You seem lost.",map:["888888888","880000888","880800008","800880008","800880008","800880008","888880008","888888888"],config:{cols:9,rows:8,maxMoves:24,heroStart:{r:2,c:1},girls:[{r:1,c:5}],rocks:[{r:4,c:5},{r:4,c:6},{r:4,c:7}],mobs:[{r:1,c:7},{r:2,c:6},{r:5,c:2}],spikes:[{r:3,c:6},{r:4,c:5},{r:4,c:6},{r:5,c:4},{r:5,c:5},{r:4,c:2}],toggleSpikes:[],keys:[],locks:[]}},
    {type:'PUZZLE',title:"LEVEL III",demonName:"Cerberus",demonLine:"Please take us with you!",map:["8888888888","8888000088","8888888088","8880000008","8880808008","8880000088","8080808088","8000000088","8888888888"],config:{cols:10,rows:9,maxMoves:32,heroStart:{r:5,c:8},girls:[{r:7,c:4},{r:7,c:5},{r:7,c:6}],rocks:[],mobs:[{r:1,c:6},{r:3,c:5}],spikes:[{r:2,c:3},{r:2,c:5},{r:3,c:6},{r:3,c:7},{r:4,c:3},{r:4,c:5},{r:5,c:4},{r:5,c:5}],toggleSpikes:[],keys:[{r:2,c:1}],locks:[{r:6,c:7}]}},
    {type:'PUZZLE',title:"LEVEL IV",demonName:"Malina",demonLine:"Turn-based strategy?",map:["8888888888","8080008888","8000000088","8000000008","8000000008","8800000888","8888888888"],config:{cols:10,rows:7,maxMoves:23,heroStart:{r:5,c:1},girls:[{r:3,c:8}],keys:[{r:5,c:3}],locks:[{r:4,c:6}],spikes:[{r:4,c:3},{r:4,c:4}],toggleSpikes:[],mobs:[],rocks:[{r:1,c:3},{r:1,c:5},{r:2,c:2},{r:2,c:4},{r:2,c:6},{r:2,c:7},{r:3,c:1},{r:3,c:3},{r:3,c:5},{r:3,c:6},{r:4,c:2},{r:4,c:4},{r:5,c:5}]}},
    {type:'PUZZLE',title:"LEVEL V",demonName:"Zdrada",demonLine:"Took you long enough.",map:["88888888","88880088","88800008","80800008","80800008","80800008","80000008","88888808","88888888"],config:{cols:8,rows:9,maxMoves:23,heroStart:{r:5,c:1},girls:[{r:7,c:5}],keys:[{r:1,c:6}],locks:[{r:6,c:4}],mobs:[{r:3,c:1}],rocks:[{r:3,c:3},{r:3,c:4},{r:3,c:5},{r:3,c:6},{r:5,c:5},{r:6,c:5}],spikes:[],toggleSpikes:[{r:2,c:1},{r:2,c:3},{r:2,c:6},{r:4,c:4},{r:4,c:6},{r:5,c:3}]}},
    {type:'PUZZLE',title:"LEVEL VI",demonName:"Azazel",demonLine:"Fascinating!",map:["888888888","880008888","880008888","800008888","880000888","880800008","880000088","888880008","888880088","888888888"],config:{cols:9,rows:10,maxMoves:43,heroStart:{r:8,c:3},girls:[{r:1,c:6}],keys:[{r:6,c:4}],locks:[{r:2,c:5}],mobs:[{r:3,c:6},{r:4,c:2}],rocks:[{r:2,c:6},{r:3,c:4},{r:4,c:4},{r:4,c:5},{r:5,c:3},{r:7,c:2},{r:7,c:3},{r:7,c:4}],spikes:[],toggleSpikes:[{r:5,c:2},{r:5,c:3}]}},
    {type:'PUZZLE',title:"LEVEL VII",demonName:"Justice",demonLine:"Let's skip the puzzle.",map:["88888888","88880088","88880008","80080008","80000008","80800008","80880888","80000888","88888888"],config:{cols:8,rows:9,maxMoves:32,heroStart:{r:3,c:6},girls:[{r:7,c:4}],keys:[{r:5,c:2}],locks:[{r:6,c:5}],mobs:[{r:3,c:3},{r:4,c:1},{r:4,c:4}],rocks:[{r:4,c:2},{r:4,c:5},{r:5,c:4},{r:5,c:5},{r:5,c:6}],spikes:[],toggleSpikes:[{r:1,c:1,startActive:false},{r:1,c:3,startActive:false},{r:2,c:4,startActive:false},{r:1,c:2,startActive:true},{r:1,c:4,startActive:true},{r:2,c:1,startActive:true}]}},
    {type:'PUZZLE',title:"LEVEL VIII",demonName:"Lucifer",demonLine:"You think you can walk in?",map:["88888888888","88888088888","88000000088","88080008088","88000000088","88080008088","88000000088","88080008088","88000000088","88080008088","88000000088","88080008088","88000000088","88880008888","88888888888"],config:{cols:11,rows:15,maxMoves:12,cameraFollow:true,heroStart:{r:3,c:5},girls:[{r:13,c:5}],rocks:[],keys:[],locks:[],spikes:[],toggleSpikes:[],mobs:[{r:5,c:5},{r:6,c:5},{r:7,c:5},{r:8,c:5},{r:9,c:5},{r:10,c:5},{r:11,c:5},{r:12,c:5}]}},
    {title:"LEVEL IX",type:'SKIP'},
    {
        type: 'BOSS',
        title: "LEVEL X", demonName: "Judgement", demonLine: "IGNITE THE SIN MACHINE!",
        config: {
            cols: 7, rows: 7, heroStart: {r:3,c:3}, maxHP: 5, bossHP: 2, chainMaxHP: 5,
            scrollDelay: 3.0, scrollTime: 1.5, phaseTime: 28.0,
            chains: [
                {t:6,v:[0]},{t:7,v:[1]},{t:8,v:[2]},{t:9,v:[3]},{t:10,v:[4]},
                {t:12,v:[6]},{t:12.5,v:[5]},{t:13,v:[4]},{t:13.5,v:[3]},{t:14,v:[2]},
                {t:15,v:[0]},{t:16,v:[2]},{t:17,v:[4]},
                {t:18,v:[1,6]},{t:19,v:[0,3]},{t:19.5,v:[2,5]},{t:20,v:[4]},{t:21,v:[6]},
                {t:23,v:[3]},{t:24,v:[0,6]},{t:25,v:[2,4]},{t:26,v:[1,5]},{t:27,v:[0,3,6]}
            ]
        }
    }
];

const PALETTE = {
    bg:'#1a1a1a',void:'#0f0f0f',floor1:'#2e2929',floor2:'#262222',wallSide:'#3d3030',
    heroSuit:'#fff',heroShirt:'#222',heroSkin:'#ffe0bd',demonSkin:'#d6a6a6',demonRed:'#ff0044',
    bone:'#e0e0e0',rock:'#e3e3e3',spike:'#555',spikeActive:'#a00',key:'#ffd700',lock:'#888',
    chain:'#fff',chainWarn:'rgba(255,255,255,0.3)',shadow:'rgba(0,0,0,0.4)'
};

// --- ÂÖ®Â±ÄÂèòÈáè ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const elContainer = document.getElementById('game-container');
const uiStat = document.getElementById('stat-container');
const elInfoInd = document.getElementById('info-indicator');
const elKeyInd = document.getElementById('key-indicator');
const elBossHP = document.getElementById('boss-hp-container');
const elBossHPFill = document.getElementById('boss-hp-fill');

let game = {
    currentLevelIdx: 0,
    grid: [], entities: [], particles: [], 
    spikes: [], toggleSpikes: [], toggleState: 0,
    player: null, moves: 0, hasKey: false,
    bossTime: 0, hp: 0, bossPhase: 0, scrollTimer: 0, activeChains: [], invuln: 0,
    state: 'PLAYING', beat: 0, lastTime: 0, inputLocked: false, cameraY: 0
};

// --- ÁºìÂä®ÂáΩÊï∞ ---
function easeInOutQuad(t) {
    return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
}

function easeOutCubic(t) {
    return 1 - Math.pow(1 - t, 3);
}

// --- ËæÖÂä©ÂáΩÊï∞ ---
function resize() {
    const rect = elContainer.getBoundingClientRect();
    canvas.width = rect.width; canvas.height = rect.height;
    if (game.grid.length>0 || game.bossPhase>0) draw();
}
function createEntity(x,y,type) { return {x, y, vx:x, vy:y, type, dir:-1, dead:false, hp:5}; }
function getEntitiesAt(x, y) { return game.entities.filter(e => e.x === x && e.y === y && !e.dead); }
function isVoid(x, y, conf) { if (x < 0 || x >= conf.cols || y < 0 || y >= conf.rows) return true; return game.grid[y][x] === 8; }
function isSpike(x, y) { return game.spikes.some(s => s.x === x && s.y === y); }
function isToggleSpike(x, y) { return game.toggleSpikes.some(s => s.x === x && s.y === y); }
function isToggleSpikeActive(s) { if (s.startActive) return game.toggleState === 0; else return game.toggleState === 1; }
function lockInput(ms) { game.inputLocked = true; setTimeout(() => game.inputLocked = false, ms); }
function hideModals() { document.querySelectorAll('.modal-overlay').forEach(el=>{ el.classList.remove('show'); setTimeout(()=>el.style.display='none',200); }); }
function screenShake(i) { elContainer.classList.remove('shake'); void elContainer.offsetWidth; elContainer.classList.add('shake'); }

function showModal(type, title, text, btnText) {
    let m = document.getElementById(`modal-${type}`);
    if(type==='levels') {
        const list=document.getElementById('level-list'); list.innerHTML='';
        LEVELS.forEach((l,i)=>{
            if(l.type==='SKIP')return;
            const btn=document.createElement('button'); btn.className='btn btn-modal btn-level-select';
            btn.innerText=(i===LEVELS.length-1)?'X':(i+1);
            if(i===game.currentLevelIdx) btn.style.borderColor=PALETTE.demonRed;
            btn.onclick=()=>{ loadLevel(i); hideModals(); }; list.appendChild(btn);
        });
    } else if(type==='dialogue') {
        document.getElementById('dia-title').innerText=title; document.getElementById('dia-text').innerText=text;
        const btn=document.getElementById('btn-next'); btn.innerText=btnText;
        btn.onclick=()=>{ 
            if(title==='GAME OVER') resetGame(); 
            else if(btnText==='MENU') { loadLevel(0); }
            else if(game.currentLevelIdx<LEVELS.length-1) loadLevel(game.currentLevelIdx+1); 
            else loadLevel(0);
        };
    }
    m.style.display='flex'; setTimeout(()=>m.classList.add('show'),10);
}

function updateUI() {
    if(LEVELS[game.currentLevelIdx].type==='BOSS') {
        uiStat.innerHTML=`HP: <span class="highlight">${game.hp}</span>`;
        elInfoInd.innerHTML = game.bossPhase===0?'PREPARE...':(game.bossPhase===1?'SURVIVE!':'DESTROY!');
        elInfoInd.classList.add('visible');
    } else {
        uiStat.innerHTML=`WILL: <span class="highlight" style="${game.moves<=5?'color:red':''}">${game.moves}</span>`;
        if(game.hasKey) elKeyInd.classList.add('visible'); else elKeyInd.classList.remove('visible');
    }
}

function spawnParticle(x,y,c,t='square'){ game.particles.push({x:x+0.5,y:y+0.5,vx:(Math.random()-0.5)*0.1,vy:(Math.random()-1)*0.1,color:c,life:1.0,size:Math.random()*2+1,type:t}); }
function spawnExplosion(x,y){ for(let i=0;i<15;i++) spawnParticle(x,y,PALETTE.bone); }
function spawnImpact(x,y){ for(let i=0;i<8;i++) spawnParticle(x,y,'#fff'); }
function spawnDust(x,y){ for(let i=0;i<5;i++) spawnParticle(x,y,'#888'); }
function spawnHearts(x,y){ for(let i=0;i<5;i++) spawnParticle(x,y,PALETTE.demonRed,'heart'); }
function spawnBlood(x,y){ for(let i=0;i<8;i++) spawnParticle(x,y,'#ff0000'); }
function spawnSparkles(x,y,c){ for(let i=0;i<10;i++) spawnParticle(x,y,c); }

function drawParticles(TS, visualOffset = 0) {
    game.particles.forEach(p => {
        ctx.globalAlpha = p.life; ctx.fillStyle = p.color;
        const size = p.size * TS * 0.1; 
        // Â∫îÁî®ËßÜËßâÂÅèÁßª
        ctx.fillRect((p.x) * TS, (p.y + visualOffset) * TS, size, size);
        ctx.globalAlpha = 1.0;
    });
}

// --- ÂàùÂßãÂåñÈÄªËæë ---
function init() { resize(); loadLevel(0); window.requestAnimationFrame(loop); }
function resetGame() { loadLevel(game.currentLevelIdx); }

function loadLevel(idx) {
    if (idx<0 || idx>=LEVELS.length) idx=0;
    if (LEVELS[idx].type==='SKIP') { loadLevel(idx+1); return; }
    game.currentLevelIdx = idx;
    const lvl = LEVELS[idx];
    document.getElementById('level-indicator').innerText = lvl.title;
    
    game.entities=[]; game.particles=[]; game.inputLocked=false;
    game.beat=0; game.state='PLAYING';
    elBossHP.style.display='none';
    elInfoInd.innerHTML=''; elInfoInd.classList.remove('visible');
    elKeyInd.classList.remove('visible');

    if (lvl.type === 'PUZZLE') initPuzzle(lvl);
    else initBoss(lvl);
    
    updateUI(); hideModals();
}

function initPuzzle(lvl) {
    const conf=lvl.config; game.grid=[]; game.spikes=[]; game.toggleSpikes=[]; 
    game.hasKey=false; game.moves=conf.maxMoves; game.toggleState=0; game.cameraY=0; game.bossPhase=-1;
    for(let y=0; y<lvl.map.length; y++) {
        let row=[]; for(let x=0; x<lvl.map[y].length; x++) row.push(parseInt(lvl.map[y][x]));
        game.grid.push(row);
    }
    const toCY = r => (conf.rows-1)-r;
    game.player = createEntity(conf.heroStart.c, toCY(conf.heroStart.r), 'hero');
    game.entities.push(game.player); game.cameraY = game.player.vy;
    if(conf.girls) conf.girls.forEach(p=>game.entities.push(createEntity(p.c,toCY(p.r),'girl')));
    if(conf.rocks) conf.rocks.forEach(p=>game.entities.push(createEntity(p.c,toCY(p.r),'rock')));
    if(conf.mobs) conf.mobs.forEach(p=>game.entities.push(createEntity(p.c,toCY(p.r),'mob')));
    if(conf.keys) conf.keys.forEach(p=>game.entities.push(createEntity(p.c,toCY(p.r),'key')));
    if(conf.locks) conf.locks.forEach(p=>game.entities.push(createEntity(p.c,toCY(p.r),'lock')));
    if(conf.spikes) conf.spikes.forEach(p=>game.spikes.push({x:p.c,y:toCY(p.r)}));
    if(conf.toggleSpikes) conf.toggleSpikes.forEach(p=>game.toggleSpikes.push({x:p.c,y:toCY(p.r),startActive:p.startActive===true}));
}

function initBoss(lvl) {
    const conf=lvl.config; game.bossPhase=0; game.bossTime=0; game.hp=conf.maxHP;
    game.scrollTimer=0; game.invuln=0; game.grid=[]; game.activeChains=[];
    for(let r=0; r<7; r++) game.grid.push([0,0,0,0,0,0,0]);
    game.player = createEntity(3,3,'hero'); game.entities.push(game.player);
    elBossHPFill.style.width='100%';
}

// --- Ê∏∏ÊàèÂæ™ÁéØ ---
function loop(timestamp) {
    let dt = (timestamp - game.lastTime)/1000; if(dt>0.1) dt=0.1;
    game.lastTime = timestamp;
    if(game.state==='PLAYING') {
        if(LEVELS[game.currentLevelIdx].type==='BOSS') updateBoss(dt);
        else updatePuzzle(dt);
    }
    draw(); window.requestAnimationFrame(loop);
}

function updatePuzzle(dt) {
    game.beat = (Date.now()/500)%1;
    const conf = LEVELS[game.currentLevelIdx].config;
    if(conf.cameraFollow) game.cameraY += (game.player.vy - game.cameraY)*0.1;
    game.entities.forEach(e=>{ e.vx+=(e.x-e.vx)*0.25; e.vy+=(e.y-e.vy)*0.25; });
    for(let i=game.particles.length-1; i>=0; i--){
        let p=game.particles[i]; p.x+=p.vx; p.y+=p.vy; p.vy+=0.015; p.life-=2.0*dt;
        if(p.life<=0) game.particles.splice(i,1);
    }
}

function updateBoss(dt) {
    const conf = LEVELS[game.currentLevelIdx].config;
    game.bossTime += dt;
    game.beat = (game.bossTime*2.5)%1;
    if(game.invuln>0) game.invuln-=dt;

    if(game.bossPhase===0) {
        if(game.bossTime > conf.scrollDelay) game.bossPhase=1;
    }

    if(game.bossPhase===1) {
        const oldTimer = game.scrollTimer;
        game.scrollTimer += dt;
        
        // ÊªöÂä®ÂºÄÂßãÊó∂ÁîüÊàêÁ≤íÂ≠êÊïàÊûú
        if (Math.floor(oldTimer / 2.0) !== Math.floor(game.scrollTimer / 2.0)) {
            for(let c=0; c<7; c++) {
                spawnParticle(c, 6.5, PALETTE.bone);
            }
        }
        
        if (game.scrollTimer >= 2.0) {
            game.scrollTimer -= 2.0;
            game.player.y -= 1; 
            game.player.vy -= 1;
            if (game.player.y < 0) takeDamage();
        }

        if(game.player.y < 0 || game.player.y > 6) takeDamage();

        conf.chains.forEach(evt => {
            if(game.bossTime >= evt.t && game.bossTime < evt.t + 0.75) {
                if(!game.activeChains.find(c=>c.t===evt.t)) game.activeChains.push({t:evt.t, v:evt.v, state:'WARN', timer:0});
            }
        });
        game.activeChains.forEach(c => {
            c.timer += dt;
            if(c.state==='WARN' && c.timer >= 0.75) {
                c.state = 'HIT'; screenShake(5);
                c.v.forEach(col => { if(Math.abs(game.player.x - col) < 0.6) takeDamage(); });
            }
            if(c.timer >= 1.0) c.done=true;
        });
        game.activeChains = game.activeChains.filter(c=>!c.done);

        if(game.bossTime >= conf.phaseTime) {
            game.bossPhase = 2;
            game.player.y = Math.round(game.player.y); game.player.x = Math.round(game.player.x);
            game.entities.push(createEntity(0,3,'chain_target'));
            game.entities.push(createEntity(6,3,'chain_target'));
            elBossHP.style.display='block';
        }
    }

    game.player.vx += (game.player.x - game.player.vx)*0.5;
    
    if(game.bossPhase===1) {
        let visualOffset = 0;
        if (game.scrollTimer > 0.5) {
            const scrollPhase = (game.scrollTimer - 0.5) / 1.5;
            visualOffset = -easeInOutQuad(scrollPhase);
        }
        game.player.vy = game.player.y + visualOffset;
    } else {
        game.player.vy += (game.player.y - game.player.vy)*0.5;
    }

    for(let i=game.particles.length-1; i>=0; i--){
        let p=game.particles[i]; p.x+=p.vx; p.y+=p.vy; p.vy+=0.015; p.life-=2.0*dt;
        if(p.life<=0) game.particles.splice(i,1);
    }
}

function takeDamage() {
    if(game.invuln>0 || game.state!=='PLAYING') return;
    game.hp--; game.invuln=1.5; screenShake(10); spawnBlood(game.player.vx, game.player.vy);
    updateUI();
    if(game.hp<=0) {
        game.state='LOST';
        setTimeout(()=>showModal('dialogue',"GAME OVER","Judgement has claimed your soul.","RETRY"),300);
    }
}

// --- ËæìÂÖ•Â§ÑÁêÜ ---
function handleInput(dx, dy) {
    if(game.state!=='PLAYING' || game.inputLocked) return;
    if(LEVELS[game.currentLevelIdx].type==='BOSS') handleBossInput(dx,dy);
    else handlePuzzleInput(dx,dy);
}

function handleBossInput(dx, dy) {
    if(dx!==0) game.player.dir=dx;
    let tx = Math.round(game.player.x)+dx; let ty = Math.round(game.player.y)+dy;
    if(tx<0||tx>6||ty<0||ty>6) return;

    if(game.bossPhase===2) {
        let chains = game.entities.filter(e=>e.type==='chain_target');
        let hit = chains.find(c=>c.x===tx && c.y===ty);
        if(hit) {
            hit.hp--; spawnImpact(tx,ty); screenShake(5);
            if(hit.hp<=0) { hit.dead=true; game.entities=game.entities.filter(e=>!e.dead); }
            let totalHP = game.entities.filter(e=>e.type==='chain_target').reduce((s,c)=>s+c.hp,0);
            elBossHPFill.style.width = (totalHP/10*100)+'%';
            if(totalHP<=0) {
                game.state='WON';
                setTimeout(()=>showModal('dialogue',"SUCCESS","Judgement: 'FINE! I'll join you!'","MENU"),500);
            }
            return;
        }
    }
    game.player.x=tx; game.player.y=ty; lockInput(120);
}

function handlePuzzleInput(dx, dy) {
    if(dx!==0) game.player.dir=dx;
    let tx=game.player.x+dx, ty=game.player.y+dy;
    let conf=LEVELS[game.currentLevelIdx].config;
    if(isVoid(tx,ty,conf)) { screenShake(3); return; }
    
    let targetEntities = getEntitiesAt(tx, ty);
    let blocker = targetEntities.find(e => ['rock', 'mob', 'lock', 'girl'].includes(e.type));
    let turnPassed = false, playerMoves = false, cost = 1;
    let nextToggleState = 1 - game.toggleState;

    if (!blocker) { turnPassed=true; playerMoves=true; }
    else {
        if(blocker.type==='girl') checkWin();
        else if(blocker.type==='lock') { if(game.hasKey){ blocker.dead=true; game.hasKey=false; spawnSparkles(tx,ty,'#fff'); screenShake(5); turnPassed=true; playerMoves=true;} else screenShake(3); }
        else if(blocker.type==='rock') { 
            let bx=tx+dx, by=ty+dy; 
            let behindBlocker = getEntitiesAt(bx,by).find(e=>['rock','mob','lock','girl'].includes(e.type));
            if(!isVoid(bx,by,conf) && !behindBlocker) { blocker.x=bx; blocker.y=by; spawnDust(tx,ty); turnPassed=true; playerMoves=false; } else screenShake(3); 
        }
        else if(blocker.type==='mob') { 
            let bx=tx+dx, by=ty+dy; 
            let behindBlocker = getEntitiesAt(bx,by).some(e=>['rock','mob','lock','girl'].includes(e.type));
            if(!isVoid(bx,by,conf) && !behindBlocker) { blocker.x=bx; blocker.y=by; spawnImpact(tx,ty); turnPassed=true; playerMoves=false; } else { blocker.dead=true; spawnExplosion(tx,ty); screenShake(8); turnPassed=true; playerMoves=false; }
        }
    }

    if(turnPassed) {
        if(playerMoves) {
            game.player.x=tx; game.player.y=ty;
            let k = getEntitiesAt(tx,ty).find(e=>e.type==='key');
            if(k) { k.dead=true; game.hasKey=true; spawnSparkles(tx,ty,PALETTE.key); }
        }
        let fx=game.player.x, fy=game.player.y;
        if(isSpike(fx,fy)) cost=2;
        let ts=game.toggleSpikes.find(s=>s.x===fx && s.y===fy);
        if(ts && ((ts.startActive && nextToggleState===0) || (!ts.startActive && nextToggleState===1))) cost=2;
        
        game.moves-=cost; game.toggleState=nextToggleState;
        
        let activeState = game.toggleState===1; 
        game.toggleSpikes.forEach(s => {
            let active = s.startActive ? !activeState : activeState;
            if(active) getEntitiesAt(s.x,s.y).filter(e=>e.type==='mob').forEach(m=>{m.dead=true; spawnExplosion(s.x,s.y);});
        });

        if(cost>1) { spawnBlood(game.player.vx, game.player.vy); screenShake(4); }
        game.entities=game.entities.filter(e=>!e.dead);
        updateUI(); lockInput(100); checkWin();
        if(game.state!=='WON' && game.moves<=0) { game.state='LOST'; setTimeout(()=>showModal('dialogue',"GAME OVER","You ran out of Willpower.","RETRY"),300); }
    }
}

function checkWin() {
    let girls = game.entities.filter(e=>e.type==='girl');
    if(girls.some(g=>Math.abs(game.player.x-g.x)+Math.abs(game.player.y-g.y)<=1)) {
        game.state='WON';
        const isLast=game.currentLevelIdx===LEVELS.length-1;
        setTimeout(()=>showModal('dialogue',"SUCCESS",`"${LEVELS[game.currentLevelIdx].demonLine}"`,isLast?"FINISH":"NEXT"),200);
        girls.forEach(g=>spawnHearts(g.vx,g.vy));
    }
}

// --- ÁªòÂà∂ÂáΩÊï∞ ---
function draw() {
    ctx.fillStyle = PALETTE.void; ctx.fillRect(0, 0, canvas.width, canvas.height);
    if(LEVELS[game.currentLevelIdx].type==='BOSS') drawBossScene();
    else drawPuzzleScene();
}

function drawBossScene() {
    const padding=20;
    const TS = Math.floor(Math.min((canvas.width-padding*2)/7, (canvas.height-padding*2)/7));
    const startX=(canvas.width-TS*7)/2, startY=(canvas.height-TS*7)/2;
    ctx.save(); ctx.translate(startX, startY);

    let visualOffset = 0;
    let extraRow1Offset=0, extraRow2Offset=0, topSpikeAlpha=1, bottomSpikeAlpha=0;
    
    if(game.bossPhase===1) {
        const progress = game.scrollTimer / 2.0; 
        const easedProgress = easeInOutQuad(progress);
        
        // ÁªòÂà∂ÊªöÂä®ÊåáÁ§∫Âô®
        ctx.fillStyle = PALETTE.demonRed;
        ctx.globalAlpha = 0.5;
        if(progress < 0.5) {
            const prepProgress = progress / 0.5;
            ctx.fillRect(0, 0, 7 * TS * prepProgress, TS * 0.1);
        } else {
            const scrollProgress = (progress - 0.5) / 1.5;
            ctx.fillRect(0, 0, 7 * TS * scrollProgress, TS * 0.1);
        }
        ctx.globalAlpha = 1.0;
        
        // Á¨¨-1Ë°åÂä®Áîª
        if(easedProgress < 0.25) { 
            extraRow1Offset = -1 + (easedProgress/0.25); 
        } else { 
            extraRow1Offset = 0; 
        }
        
        // Á¨¨7Ë°åÂä®Áîª
        if(easedProgress >= 0.125 && easedProgress < 0.375) { 
            extraRow2Offset = 1 - ((easedProgress-0.125)/0.25); 
        } else if(easedProgress >= 0.375) { 
            extraRow2Offset = 0; 
        }

        // Â∞ñÂà∫Âä®Áîª
        if(easedProgress >= 0.25 && easedProgress < 0.5) {
            let sp = (easedProgress-0.25)/0.25; 
            topSpikeAlpha = 1-sp; 
            bottomSpikeAlpha = sp;
        } else if(easedProgress >= 0.5) { 
            topSpikeAlpha=0; 
            bottomSpikeAlpha=1; 
        }

        // ÊªöÂä®Âä®Áîª
        if(easedProgress >= 0.5) {
            const scrollPhase = (easedProgress - 0.5) / 0.5;
            visualOffset = -easeInOutQuad(scrollPhase);
        }
    }
    
    // ÁªòÂà∂Âú∞Âõæ
    for(let r=-2; r<=8; r++) {
        for(let c=0; c<7; c++) {
            let drawY = (r + visualOffset) * TS;
            if(r===-1) drawY += extraRow1Offset * TS;
            if(r===7) drawY += extraRow2Offset * TS;

            if(drawY > -TS && drawY < canvas.height - startY + TS) {
                ctx.fillStyle = (c+r)%2===0 ? PALETTE.floor1 : PALETTE.floor2;
                ctx.fillRect(c*TS, drawY, TS, TS);
                if(r===0) drawSpike(ctx,c*TS,drawY,TS,true,false,topSpikeAlpha);
                if(r===6) drawSpike(ctx,c*TS,drawY,TS,true,false,bottomSpikeAlpha);
                if(r===-1 && extraRow1Offset===0) drawSpike(ctx,c*TS,drawY,TS,true,false,1);
                if(r===7 && extraRow2Offset===0) drawSpike(ctx,c*TS,drawY,TS,true,false,1);
            }
        }
    }

    // ÁªòÂà∂ÈìæÊù°ÔºàË∑üÈöèÊªöÂä®Ôºâ
    game.activeChains.forEach(c => {
        ctx.fillStyle = c.state==='WARN' ? PALETTE.chainWarn : PALETTE.chain;
        c.v.forEach(col => {
            const y = visualOffset * TS;
            ctx.fillRect(col*TS + TS*0.2, y, TS*0.6, 7*TS);
        });
    });

    // ÁªòÂà∂BOSSÁ¨¨‰∫åÈò∂ÊÆµÁõÆÊ†á
    if(game.bossPhase===2) { 
        drawChainTarget(ctx,0*TS,(3+visualOffset)*TS,TS); 
        drawChainTarget(ctx,6*TS,(3+visualOffset)*TS,TS); 
    }

    // ÁªòÂà∂Áé©ÂÆ∂
    const CX = game.player.vx*TS + TS/2; 
    const CY = (game.player.y + visualOffset)*TS + TS/2;
    ctx.save();
    ctx.translate(CX, CY);
    if(game.invuln<=0 || Math.floor(Date.now()/100)%2===0) drawHero(ctx, TS, 0, game.player.dir);
    ctx.restore();
    
    // ÁªòÂà∂Á≤íÂ≠êÔºàÂ∫îÁî®ËßÜËßâÂÅèÁßªÔºâ
    drawParticles(TS, visualOffset);
    ctx.restore();
}

function drawPuzzleScene() {
    const conf = LEVELS[game.currentLevelIdx].config;
    const padding = 20; const availW=canvas.width-padding*2, availH=canvas.height-padding*2;
    let TS = Math.floor(Math.min(availW/conf.cols, availH/conf.rows));
    if(conf.cameraFollow) TS = Math.floor(availW/conf.cols);
    const startX=(canvas.width-TS*conf.cols)/2;
    let startY = (canvas.height-TS*conf.rows)/2;
    if(conf.cameraFollow) {
        const centerY = canvas.height/2; const py = game.cameraY * TS + TS/2;
        startY = Math.max(canvas.height-(conf.rows*TS)-padding, Math.min(padding, centerY-py));
    }
    ctx.save(); ctx.translate(startX, startY);
    for(let y=0; y<conf.rows; y++){
        for(let x=0; x<conf.cols; x++){
            if(game.grid[y][x]===8) continue;
            ctx.fillStyle = ((x+y)%2===0)?PALETTE.floor1:PALETTE.floor2; ctx.fillRect(x*TS, y*TS, TS, TS);
            if(isSpike(x,y)) drawSpike(ctx,x*TS,y*TS,TS,true);
            let ts=game.toggleSpikes.find(s=>s.x===x && s.y===y);
            if(ts) drawSpike(ctx,x*TS,y*TS,TS,isToggleSpikeActive(ts),true);
            if(y===conf.rows-1 || game.grid[y+1][x]===8) { ctx.fillStyle=PALETTE.wallSide; ctx.fillRect(x*TS,y*TS+TS,TS,TS*0.2); }
        }
    }
    game.entities.sort((a,b)=>{ if(a.vy!==b.vy)return a.vy-b.vy; let za=(a.type==='key')?0:(a.type==='hero'?2:1); let zb=(b.type==='key')?0:(b.type==='hero'?2:1); return za-zb; });
    game.entities.forEach(e=>{
        const CX=e.vx*TS+TS/2, CY=e.vy*TS+TS/2; const bop=Math.sin(game.beat*Math.PI*2)*(TS*0.03);
        ctx.save(); ctx.translate(CX,CY);
        if(e.type!=='key') { ctx.fillStyle=PALETTE.shadow; ctx.beginPath(); ctx.ellipse(0,TS*0.35,TS*0.3,TS*0.1,0,0,Math.PI*2); ctx.fill(); }
        if(e.type==='hero') drawHero(ctx,TS,bop,e.dir);
        else if(e.type==='girl') drawGirl(ctx,TS,bop,e.vx,e.vy);
        else if(e.type==='rock') drawRock(ctx,TS,game.currentLevelIdx+1);
        else if(e.type==='mob') drawMob(ctx,TS,bop);
        else if(e.type==='key') drawKey(ctx,TS,bop);
        else if(e.type==='lock') drawLock(ctx,TS);
        ctx.restore();
    });
    drawParticles(TS);
    ctx.restore();
}

// --- ÁªòÂà∂ËæÖÂä©ÂáΩÊï∞ ---
function drawKey(ctx,s,b){ ctx.translate(0,b); ctx.fillStyle=PALETTE.key; ctx.beginPath(); ctx.arc(0,-s*0.1,s*0.15,0,Math.PI*2); ctx.fill(); ctx.fillRect(-s*0.05,0,s*0.1,s*0.3); ctx.fillRect(0,s*0.15,s*0.15,s*0.08); }
function drawLock(ctx,s){ ctx.fillStyle=PALETTE.lock; ctx.fillRect(-s*0.35,-s*0.2,s*0.7,s*0.6); ctx.strokeStyle=PALETTE.lock; ctx.lineWidth=s*0.08; ctx.beginPath(); ctx.arc(0,-s*0.2,s*0.15,Math.PI,0); ctx.stroke(); ctx.fillStyle='#111'; ctx.beginPath(); ctx.arc(0,s*0.1,s*0.08,0,Math.PI*2); ctx.fill(); }
function drawSpike(ctx,x,y,s,active,toggle,alpha=1){ 
    ctx.save(); ctx.globalAlpha=alpha; 
    if(active){ 
        ctx.fillStyle=toggle?PALETTE.spikeActive:PALETTE.spike; const h=toggle?s*0.6:s*0.4; 
        ctx.beginPath(); ctx.moveTo(x+s*0.2,y+s*0.8); ctx.lineTo(x+s*0.3,y+s*0.8-h); ctx.lineTo(x+s*0.4,y+s*0.8); 
        ctx.moveTo(x+s*0.45,y+s*0.8); ctx.lineTo(x+s*0.55,y+s*0.8-h); ctx.lineTo(x+s*0.65,y+s*0.8); 
        ctx.moveTo(x+s*0.7,y+s*0.8); ctx.lineTo(x+s*0.8,y+s*0.8-h); ctx.lineTo(x+s*0.9,y+s*0.8); ctx.fill(); 
    } else { 
        ctx.fillStyle='rgba(0,0,0,0.4)'; 
        ctx.beginPath(); ctx.moveTo(x+s*0.1,y+s*0.9); ctx.lineTo(x+s*0.3,y+s*0.7); ctx.stroke(); 
        ctx.beginPath(); ctx.moveTo(x+s*0.9,y+s*0.9); ctx.lineTo(x+s*0.7,y+s*0.7); ctx.stroke(); 
        ctx.beginPath(); ctx.arc(x+s*0.5,y+s*0.5,s*0.1,0,Math.PI*2); ctx.fill(); 
    } 
    ctx.restore(); 
}
function drawHero(ctx,s,b,d){ const w=s*0.4, h=s*0.6; ctx.translate(0,b); ctx.fillStyle=PALETTE.heroSuit; ctx.fillRect(-w/2,-h/2,w,h); ctx.fillStyle=PALETTE.heroShirt; ctx.fillRect(-w/4,-h/2,w/2,h); ctx.fillStyle=PALETTE.demonRed; ctx.fillRect(-w/8,-h/4,w/4,h/3); ctx.fillStyle=PALETTE.heroSkin; ctx.fillRect(-w/2+2,-h-5,w-4,w); ctx.fillStyle='#000'; ctx.fillRect(-w/2,-h+2,w,s*0.08); }
function drawGirl(ctx,s,b,vx,vy){ const w=s*0.4, h=s*0.55; ctx.translate(0,b); ctx.fillStyle=PALETTE.demonRed; ctx.fillRect(-w/2,-h/2,w,h); ctx.fillStyle=PALETTE.demonSkin; ctx.fillRect(-w/2+2,-h-5,w-4,w); ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(0,-h,s*0.25,0,Math.PI,true); ctx.fill(); ctx.fillStyle='#000'; ctx.beginPath(); ctx.moveTo(-10,-h-10); ctx.lineTo(-15,-h-25); ctx.lineTo(-5,-h-10); ctx.moveTo(10,-h-10); ctx.lineTo(15,-h-25); ctx.lineTo(5,-h-10); ctx.fill(); if(Math.random()<0.05) spawnParticle(vx,vy,PALETTE.demonRed,'heart'); }
function drawMob(ctx,s,b){ ctx.translate(0,b); ctx.fillStyle=PALETTE.bone; ctx.beginPath(); ctx.arc(0,-s*0.2,s*0.18,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#000'; ctx.fillRect(-5,-s*0.25,4,4); ctx.fillRect(3,-s*0.25,4,4); ctx.fillStyle=PALETTE.bone; ctx.fillRect(-s*0.15,0,s*0.3,s*0.3); ctx.fillStyle='#000'; ctx.fillRect(-s*0.1,s*0.1,s*0.2,s*0.05); }
function drawRock(ctx,s,n){ ctx.fillStyle=PALETTE.rock; ctx.fillRect(-s*0.35,-s*0.35,s*0.7,s*0.7); const r=["I","II","III","IV","V","VI","VII","VIII","IX","X"][n-1]||"X"; ctx.fillStyle='#ccc'; ctx.font='bold 20px serif'; ctx.textAlign='center'; ctx.fillText(r,0,5); }
function drawChainTarget(ctx,x,y,s){ ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(x+s/2,y+s/2,s*0.3,0,Math.PI*2); ctx.fill(); ctx.strokeStyle='#000'; ctx.lineWidth=4; ctx.stroke(); ctx.fillStyle='#000'; ctx.font='20px sans-serif'; ctx.textAlign='center'; ctx.fillText('KICK',x+s/2,y+s/2+5); }

// --- ‰∫ã‰ª∂ÁõëÂê¨ ---
window.addEventListener('resize', ()=>{ resize(); });
document.getElementById('btn-restart-ui').onclick=()=>showModal('restart');
document.getElementById('btn-levels-ui').onclick=()=>showModal('levels');
document.getElementById('btn-cancel').onclick=hideModals;
document.getElementById('btn-cancel-levels').onclick=hideModals;
document.getElementById('btn-confirm').onclick=resetGame;

let tsx=0,tsy=0;
canvas.addEventListener('touchstart',e=>{ tsx=e.touches[0].clientX; tsy=e.touches[0].clientY; e.preventDefault(); }, {passive:false});
canvas.addEventListener('touchend',e=>{
    let dx=e.changedTouches[0].clientX-tsx, dy=e.changedTouches[0].clientY-tsy;
    if(Math.abs(dx)>Math.abs(dy)) handleInput(dx>0?1:-1,0); else handleInput(0,dy>0?1:-1);
});
window.addEventListener('keydown',e=>{
    if(e.repeat) return; const k=e.key.toLowerCase();
    
    // ÈòªÊ≠¢ÊñπÂêëÈîÆÊªöÂä®È°µÈù¢
    if(['arrowup','arrowdown','arrowleft','arrowright'].includes(k)) e.preventDefault();

    const modals=document.querySelectorAll('.modal-overlay');
    let modalOpen=false; modals.forEach(m=>{if(m.style.display==='flex')modalOpen=true;});
    if(modalOpen) {
        if(k==='enter') {
            if(document.getElementById('modal-restart').style.display==='flex') resetGame();
            else if(document.getElementById('modal-dialogue').style.display==='flex') document.getElementById('btn-next').click();
        }
        if(k==='escape') hideModals(); return;
    }
    if(k==='r') showModal('restart');
    if(k==='w'||k==='arrowup') handleInput(0,-1);
    else if(k==='s'||k==='arrowdown') handleInput(0,1);
    else if(k==='a'||k==='arrowleft') handleInput(-1,0);
    else if(k==='d'||k==='arrowright') handleInput(1,0);
});

// ÂêØÂä®Ê∏∏Êàè
init();
</script>
</body>
</html>